#include "SketchingScene.h"

#include <QUrl>
#include <QDir>
#include <QDebug>


SketchingScene::SketchingScene( QObject* parent ): QGraphicsScene( parent )
{
    createConnections();
}


void SketchingScene::init()
{

    QGraphicsView* view = views()[0];

    int boundary_width = view->width()*0.8;
    int boundary_height = view->height()*0.7;


    boundary = new BoundaryItem( boundary_width, boundary_height );
    addItem( boundary );
    setSceneRect( boundary->boundingRect() );


    temp_sketch = NULL;

    newSketch();
    setBackGround();

}


void SketchingScene::createConnections()
{
    connect( this, SIGNAL( sendCoordinates( float, float ) ), this->parent(), SLOT( updateCoordinates( float, float ) ) );
    connect( this->parent(), SIGNAL( newBoundary() ), this, SLOT( modeBoundary() ) );
}


void SketchingScene::setBackGround()
{
    int step = 20;

    QRadialGradient gradient( (qreal)width()*0.5f, (qreal)height()*0.5f, width() );

    for ( qreal radius = 0.0f; radius <= 1.0f; radius += 0.1f )
    {
        gradient.setColorAt( radius, QColor::fromRgb( 154.28f + ( radius*step ), 176.20f + ( radius*step ), 199.16f + ( radius*step ) ) );
    }

    setBackgroundBrush( QBrush( gradient ) );
}




void SketchingScene::newSketch()
{

    current_color = QColor( 255, 75, 75 );

    sketch = new InputSketch( current_color );
    addItem( sketch );

    current_mode = InteractionMode::OVERSKETCHING;

}


void SketchingScene::insertLastSketch()
{

    current_mode = InteractionMode::INSERTING;

    emit insertSkecthing( sketch );
    newSketch();

}


void SketchingScene::undoLastSketch()
{
    if( sketch != NULL )
        sketch->clear();

    if( temp_sketch != NULL )
        temp_sketch->clear();
}




void SketchingScene::updateColor( const QColor& color )
{
    current_color = color;

    if( temp_sketch != NULL )
        temp_sketch->setColor( color );

    if( sketch != NULL )
        sketch->setColor( color );

    update();

}




void SketchingScene::savetoRasterImage( const QString& filename )
{

    QImage image( sceneRect().size().toSize(), QImage::Format_ARGB32 );  // Create the image with the exact size of the shrunk scene
    image.fill( Qt::transparent );

    QPainter painter( &image );
    render( &painter );

    image = image.mirrored( false, true );
    image.save( filename );

}


void SketchingScene::savetoVectorImage( const QString& filename )
{

    QSvgGenerator svgGen;

    svgGen.setFileName( filename );
    svgGen.setSize( QSize( width(), height() ) );

    svgGen.setViewBox( sceneRect() );
    svgGen.setTitle( tr( "Rapid Reservoir Modelling - SVG generated by Qt5" ) );
    svgGen.setDescription( tr( "SVG output of Rapid Reservoir Modelling software" ) );

    QPainter painter( &svgGen );
    painter.scale( 1.0, -1.0 );
    painter.translate( QPointF( 0.0, -height() ) );

    render( &painter );
}





void SketchingScene::mousePressEvent( QGraphicsSceneMouseEvent *event )
{

    if ( event->buttons() & Qt::LeftButton )
    {

        if( current_mode == InteractionMode::BOUNDARY )
        {
            boundary_anchor = event->buttonDownScenePos( Qt::LeftButton );
        }

        else if( current_mode == InteractionMode::OVERSKETCHING )
        {



            temp_sketch = new InputSketch( current_color );
            temp_sketch->create( event->scenePos() );
            addItem( temp_sketch );

        }

    }

    else if (event->buttons() & Qt::RightButton )
    {
        insertLastSketch();
    }

    QGraphicsScene::mousePressEvent( event );
    update();
}


void SketchingScene::mouseMoveEvent( QGraphicsSceneMouseEvent* event )
{

    emit sendCoordinates( event->scenePos().x(), event->scenePos().y() );


    if ( event->buttons() & Qt::LeftButton )
    {

        if( current_mode == InteractionMode::OVERSKETCHING )
        {
            temp_sketch->add( event->scenePos() );
        }

        else if( current_mode == InteractionMode::BOUNDARY )
        {

            int w = event->scenePos().x() - boundary_anchor.x();
            int h = event->scenePos().y() - boundary_anchor.y();

            boundary->setNewBoundary( boundary_anchor.x(), boundary_anchor.y(), w,  h );

        }

    }

    QGraphicsScene::mouseMoveEvent( event );
    update();

}


void SketchingScene::mouseReleaseEvent( QGraphicsSceneMouseEvent* event )
{

    if ( current_mode == InteractionMode::OVERSKETCHING  )
    {

        if( temp_sketch == NULL ) return;


        sketch->addSegment( *temp_sketch );
        removeItem( temp_sketch );

        delete temp_sketch;
        temp_sketch = NULL;

    }

    else if( current_mode == InteractionMode::BOUNDARY )
    {

        int w = event->scenePos().x() - boundary_anchor.x();
        int h = event->scenePos().y() - boundary_anchor.y();

        boundary->setNewBoundary( boundary_anchor.x(), boundary_anchor.y(), w,  h );
        this->setSceneRect( boundary->boundingRect() );

        current_mode = InteractionMode::OVERSKETCHING;

    }

    QGraphicsScene::mouseReleaseEvent( event );
    update();


}




void SketchingScene::dragEnterEvent( QGraphicsSceneDragDropEvent *event )
{
    event->accept();
}


void SketchingScene::dropEvent( QGraphicsSceneDragDropEvent *event )
{

    const QMimeData *mime_data = event->mimeData();


    if ( mime_data->hasUrls() == false )
        return;


    QString url_file = mime_data->urls().at( 0 ).toLocalFile();
    url_file = QDir::toNativeSeparators( url_file );

    boundary->setBackGroundImage( url_file );

/*
    QBrush brush;
        brush.setTextureImage( QImage( url_file ) );
        setBackgroundBrush( brush );
*/

}


void SketchingScene::dragMoveEvent( QGraphicsSceneDragDropEvent * event )
{
    event->accept();
}


void SketchingScene::dragLeaveEvent( QGraphicsSceneDragDropEvent * event )
{
    event->accept();
}

